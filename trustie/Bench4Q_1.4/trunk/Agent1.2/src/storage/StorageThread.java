/**
 * =========================================================================
 * 					Bench4Q_Script version 1.3.1
 * =========================================================================
 * 
 * Bench4Q is available on the Internet at http://www.trustie.net/projects/project/show/Bench4Q
 * You can find latest version there. 
 * 
 * Bench4Q_Script adds a script module for Internet application to Bench4Q
 * you can access it at http://www.trustie.com/projects/project/show/Bench4Q_Script
 * 
 * Distributed according to the GNU Lesser General Public Licence. 
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by   
 * the Free Software Foundation; either version 2.1 of the License, or any
 * later version.
 * 
 * SEE Copyright.txt FOR FULL COPYRIGHT INFORMATION.
 * 
 * This source code is distributed "as is" in the hope that it will be
 * useful.  It comes with no warranty, and no author or distributor
 * accepts any responsibility for the consequences of its use.
 *
 *
 * This version is a based on the implementation of TPC-W from University of Wisconsin. 
 * This version used some source code of The Grinder.
 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 *  * Initial developer(s): WuYulong, Wangsa , Tianfei , Zhufeng
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
 * 
 */

/**
 * <strong>A auto exchange buffer to store increasing data generated by Agent.</strong>
 * <p>
 * Agent's storage process will be operate in this module.
 * This module will call persist module to store data in disk when exchange time.
 * </p>
 * @author wuyulong
 * @version 1.1
 */
package src.storage;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Timer;
import java.util.TimerTask;

/**
 * <strong>The core class of this module.</strong>
 * <p>
 * It instantiate the storage class and manage the store process by two timer.
 * </p> 
 * @author wuyulong
 * @version 1.1 build in 20110823
 */
public class StorageThread extends Thread{
	/**
	 * used to store test duration time get from the Agent class
	 */
	private long m_stdyTime;
	/**
	 * store the number of main page requests in script
	 */
	private int m_ScriptSize;
	/**
	 * store the number of all requests(page, img, css and so on) in script
	 */
	private int m_ScriptSize_SS;
	/**
	 * store real-time response time which is used for returning to console
	 */
	private volatile double m_curResponseTime;
	private static volatile double m_hisResponseTime;
	//store real-time throughput and response time
	/**
	 * store real-time throughput which is used for returning to console
	 */
	private volatile int m_curThroughput;
	private static volatile int m_hisThroughput;
	/**
	 * assistant variable to calculate response time
	 */
	private volatile int m_curResponseNum;
	private static volatile int m_hisResponseNum;
	/**
	 * two reference to refer the exchange buffers 
	 */
	private volatile DataStorage cur_Struc, new_Struc;
	private static long m_startTime;
	private static long m_endTime;
	/**
	 * used to count the threads which haven't canceled
	 */
	private static int m_cancelCount;
	//private static long prepareTime;
	//private static long cooldown;
	/**
	 * Timer used to fulfill exchange task periodically
	 */
	Timer exTimer;
	/**
	 * Timer used to initial new buffer periodically
	 */
	Timer initTimer;
	/**
	 * Timer used to fulfill cancel task when the tesk time is up
	 */
	Timer cancelTimer;
	/**
	 * Timer used to update real-time data for console to read periodically
	 */
	Timer updateTimer;
	/**
	 * store the exchange period and initial delay read from config file
	 */
	public static long PERIOD;
	public static long DELAY;
	/**
	 * the variable used to implement singleton
	 */
	private volatile static StorageThread uniqueInstance;
	
	/**
	 * <strong>Construction Method</strong>
	 * <p>
	 * initialize input parameter & instantiate the storage structure DataStorage.
	 * </p>
	 * @param period	the exchange period
	 * @param delay		the initial timer's delay than the exchange timer
	 * @param scriptSize		the number of main pages in agent's script,which determine the storage size to open up
	 * @param scriptSize_SS		the number of all pages in agent's script,which determine the storage size to open up
	 * @param startTime		record the startTime of the process of storage. it is used to determine time offset which determine the storage subscript.
	 * @param stdyTime		record the duration of agent's test, after this time, the StorageThread will enter cancel process to wait for the agent's all thread to cancel.
	 * @param cancelCount		used to determine whether all the threads of agent have been canceled. 
	 * 
	 * @author wuyulong
	 * @version 1.1 build in 20110823
	 */
	private StorageThread(long period, long delay, int scriptSize, int scriptSize_SS, long startTime,long stdyTime,int cancelCount) {
		PERIOD = period;
		DELAY = delay;
		m_ScriptSize = scriptSize;
		m_ScriptSize_SS = scriptSize_SS;
		m_startTime=startTime;
		m_stdyTime = stdyTime * 1000;
		m_endTime=m_startTime+m_stdyTime;
		cur_Struc = new DataStorage(m_ScriptSize, m_ScriptSize_SS);
		new_Struc = new DataStorage(m_ScriptSize, m_ScriptSize_SS);
		m_cancelCount = cancelCount;
		//m_curResponseTime=0.0;
	}
	/**
	 * <strong>Singelton: the unique method open to external module to initial StorageThread</strong>
	 * <p>
	 * Consider that all the thread of agent will share the unique StorageThread, so use singleton.
	 * </p>
	 * @param period @see SrotageThread()
	 * @param delay @see SrotageThread()
	 * @param scriptSize @see SrotageThread()
	 * @param scriptSize_SS @see SrotageThread()
	 * @param startTime @see SrotageThread()
	 * @param stdyTime @see SrotageThread()
	 * @param cancelCount @see SrotageThread()
	 * @param args @see SrotageThread()
	 * @return the unique StorageThread object
	 */
	public static StorageThread initSto(long period, long delay, int scriptSize, int scriptSize_SS, long startTime, long stdyTime,int cancelCount) {
		if (uniqueInstance == null) {
			synchronized (StorageThread.class) {
				if (uniqueInstance == null) {
					uniqueInstance = new StorageThread(period, delay, scriptSize, scriptSize_SS, startTime, stdyTime,cancelCount);
				}
			}
		}
		return uniqueInstance;
	}
	//getters and setters
	public static StorageThread getUniq() {
		return uniqueInstance;
	}
	public static long getM_startTime() {
		return m_startTime;
	}
	public static void setM_startTime(long mStartTime) {
		m_startTime = mStartTime;
	}
	public static long getM_endTime(){
		return m_endTime;
	}
	public DataStorage getCur_Struc() {
		return cur_Struc;
	}
	public void setCur_Struc(DataStorage curStruc) {
		cur_Struc = curStruc;
	}
	public DataStorage getNew_Struc() {
		return new_Struc;
	}
	public void setNew_Struc(DataStorage newStruc) {
		new_Struc = newStruc;
	}
	//getters and setters end
	
	/**
	 * used to count the number exited of agent's threads.
	 */
	public synchronized void updateCancelCount() {
		m_cancelCount--;
		if(m_cancelCount<0) {
			System.out.println("DEBUG TIME ERROR[008]: please check the consistency of m_cancelCount");
		}
	}
	public synchronized boolean isCanceled() {
		return (m_cancelCount!=0)?false:true;
	}
	public synchronized double getCurResponseTime() {
		return m_hisResponseTime;
	}
	public synchronized int getCurThroughput() {
		return m_hisThroughput;
	}
	/**
	 * used to update real-time data for console to do drawing in real-time
	 */
	public synchronized void updateCurData() {
		if(m_curThroughput != 0) {
		m_hisResponseNum = m_curResponseNum;
		m_hisThroughput = m_curThroughput;
		m_hisResponseTime=m_curResponseTime/m_hisResponseNum;
		m_curResponseNum = 0;
		m_curThroughput = 0;
		m_curResponseTime=0.0;
		} else {
			if(m_curResponseNum != 0 || m_curResponseTime != 0.0) {
				System.out.println("FATAL ERROR[005]: Data consistency Error");
				System.exit(-1);
			}
			m_hisResponseNum = 0;
			m_hisThroughput = 0;
			m_hisResponseTime = 0.0;
		}
		System.out.println("response time:"+m_hisResponseTime+"throughput:"+m_hisThroughput);
	}
	/**
	 * <strong>the entry to store response time</strong>
	 * @param state the page offset in script, main page offset or request offset depends on isSS
	 * @param start the start time marker of the request
	 * @param end the end time marker of the request
	 * @param isSS 
	 * 		true: this interaction is not a page request(small-size request)
	 * 		false: this interaction is a page request
	 */
	public synchronized void responsetimeRecorder(int state,long start,long end,boolean isSS)
	{
		m_curResponseNum++;
		double response=end-start;
		m_curResponseTime+=response;
		//System.out.println("StorageThread entered responsetimeRecorder with start:"+start+" end:"+end+" in "+System.currentTimeMillis());
		cur_Struc.responsetimeRecorder(state, start, end, isSS);
	}
	public synchronized void throughtputRecorder(int state, long timeMark) {
		m_curThroughput++;
		//System.out.println("StorageThread entered throughtputRecorder with timeMark:"+timeMark+" in "+System.currentTimeMillis());
		cur_Struc.throughtputRecorder(state, timeMark);
	}
	/**
	 * the method to fulfill exchange task
	 */
	public synchronized void exchange() {
		long curTime=System.currentTimeMillis();
		System.out.println("entered exchange in "+curTime);
		long ss = System.currentTimeMillis();
		new_Struc.setStartTime(curTime);
		StoFile.getInstance().sto(cur_Struc);
		System.out.println("finish sto process within "+(System.currentTimeMillis()-ss));
		cur_Struc = new_Struc;
//		ss = System.currentTimeMillis();
//		System.out.println("setStartTime:"+ss);
//		cur_Struc.setStartTime(ss);
//		MySQLite.store(t);	//store to SQLite
		new_Struc = new DataStorage(m_ScriptSize, m_ScriptSize_SS);
	}
	public synchronized void initNew() {
		if(new_Struc != null) {
			System.out.println("initNew Error.");
		}
		new_Struc.init(false);
	}
	public void run() {
		if(uniqueInstance == null)
			return;
		//System.out.println("run storage");
		cancelTimer = new Timer("cancelTimer");
		cancelTimer.schedule(new CancelTask(this), m_stdyTime);
		updateTimer = new Timer("updateResponseTimer");
		updateTimer.schedule(new UpdateTask(this), 100, 1000);
		exTimer = new Timer("exTimer");
		exTimer.schedule(new ExchangeTask(this), 0, PERIOD);
		initTimer = new Timer("initTimer");
		initTimer.schedule(new InitTask(this), DELAY, PERIOD);
	}
}
class UpdateTask extends TimerTask {
	private volatile StorageThread st;
	public UpdateTask(StorageThread st) {
		this.st = st;
	}
	public void run() {
		st.updateCurData();
	}
}
class CancelTask extends TimerTask {
	private volatile StorageThread st;
	public CancelTask(StorageThread st) {
		this.st = st;
	}
	public void run() {
		//unfinished...
		System.out.println("StorageThread is waiting for Agent's threads canceled...");
		while(!st.isCanceled()) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			Thread.yield();
		}
		System.out.println("Agent's threads has all canceled,starting Storage cancel process...");
		st.exTimer.cancel();
		st.initTimer.cancel();
		StoFile.getInstance().sto(st.getCur_Struc());	//store the remainder data
		st.updateTimer.cancel();
		st.cancelTimer.cancel();
	}
}
class ExchangeTask extends TimerTask {
	private volatile StorageThread  st;
	boolean firstFlag;
	public ExchangeTask(StorageThread st) {
		this.st = st;
		firstFlag = true;
	}
	public void run() {
		System.out.println("entered exTimer in "+System.currentTimeMillis());
		if(firstFlag) {
			Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
			firstInit();
		}
		else {
			st.exchange();
		}
		//System.out.println("exchangeTask complete in "+(System.currentTimeMillis()-time));
//		Thread.currentThread().setPriority(Thread.NORM_PRIORITY);
	}
	private void firstInit() {
		st.getCur_Struc().init(firstFlag);
		firstFlag = false;
	}
}
class InitTask extends TimerTask {
	private volatile StorageThread st;
	public InitTask(StorageThread st) {
		this.st = st;
	}
	public void run() {
		System.out.println("entered InitTask in "+System.currentTimeMillis());
		st.getNew_Struc().init(false);
	}
}
/**
 * package the storage structure
 */
class DataStorage{
	private long startTime;
	public int[][] webIThroughput;
	public ResponseTimeItem<Double> [][]webIResponseTime;
	public ResponseTimeItem<Double> [][]webIResponseTime_SS;
	private int scriptSize;
	private int scriptSize_SS;
	
	public DataStorage(int scriptSize, int scriptSize_SS) {
		this.scriptSize = scriptSize;
		this.scriptSize_SS = scriptSize_SS;
	}
	public void setStartTime(long startTime) {
		this.startTime = startTime;
	}
	public long getStartTime() {
		return startTime;
	}
	public void init(boolean isFirst) {
		if(isFirst)
			setStartTime(System.currentTimeMillis());
		int temp = (int)StorageThread.getUniq().PERIOD/1000;
		webIThroughput = new int[temp][scriptSize_SS];
		webIResponseTime = new ResponseTimeItem[temp][scriptSize];
		webIResponseTime_SS = new ResponseTimeItem[temp][scriptSize_SS];
		for(int i=0; i<temp; i++) {
			for(int j=0; j<scriptSize; j++)
				webIResponseTime[i][j] = new ResponseTimeItem<Double>();
		}
		for(int i=0; i<temp; i++) {
			for(int j=0; j<scriptSize_SS; j++)
				webIResponseTime_SS[i][j] = new ResponseTimeItem<Double>();
		}
	}
	/**
	 * <strong>the entry to record response time</strong>
	 * @param state @see responsetimeRecorder()
	 * @param start @see responsetimeRecorder()
	 * @param end @see responsetimeRecorder()
	 * @param isSS @see responsetimeRecorder()
	 */
	public void responsetimeRecorder(int state,long start,long end, boolean isSS)
	{
/*		//debug0807
		long dd = System.currentTimeMillis();
		System.out.println("thread"+threadNum+" has entered responsetimeRecorder in "+dd);
*/		//debug end
		long timeOffset = end - startTime;
		//System.out.println("DEBUG:timeOffset(original): "+timeOffset);
		if(timeOffset < 0)
		{
			System.out.println("FATAL ERROR[001] Single Agent Overload.");
			System.out.println("start:"+start+" startTime:"+startTime);
			System.exit(-1);
		} else if(timeOffset > Integer.MAX_VALUE) {
			System.out.println("FATAL ERROR[002] update period too long!");
			System.exit(-1);
		}else if(timeOffset > StorageThread.PERIOD) {
			/*
			System.out.println("FATAL ERROR[004] timeOffset out of bound:");
			System.exit(-1);
			*/
			System.out.println("WARNING[002]: timeOffset out of bound:"+timeOffset);
			System.out.println("end:"+end+
					" startTime:"+startTime+"timeOffset:"+timeOffset);
			timeOffset = (StorageThread.PERIOD - 1)/1000;
		} else if(timeOffset == StorageThread.PERIOD) {
			timeOffset = (timeOffset-1)/1000;	//a special op for critical value
		}
		else {
			timeOffset /= 1000;
		}
		double responseTime = end - start;
		//System.out.println("DEBUG:timeOffset: "+timeOffset);
		try {
		if(!isSS)
			webIResponseTime[(int)timeOffset][state].get().add(responseTime);
		else
			webIResponseTime_SS[(int)timeOffset][state].get().add(responseTime);
		} 
		catch(ArrayIndexOutOfBoundsException e) {
			System.out.println("startTime:"+startTime+" end:"+end+" timeOffset:"+timeOffset);
			e.printStackTrace();
		}
	}
	public void throughtputRecorder(int state, long timeMark) 
	{
		long timeOffset = timeMark - startTime;
		if(timeOffset < -1000) {	//larger than the buffer 1 second
			System.out.println("Fatal Error[001] in StorageThread.");
			System.out.println("timeMark:"+timeMark+" startTime:"+startTime);
			System.exit(-1);
		}
		else if(timeOffset < 0) {
			//for debug
			System.out.println("Fatal Error[001] in StorageThread.");
			System.out.println("timeMark:"+timeMark+" startTime:"+startTime);
			System.exit(-1);
			//debug end
			timeOffset = 0;
		} else if(timeOffset > StorageThread.PERIOD) {
			/*
			System.out.println("FATAL ERROR[004] timeOffset out of bound:");
			System.exit(-1);
			*/
			System.out.println("WARNING[001]: timeOffset out of bound:"+timeOffset);
			System.out.println("timeMark:"+timeMark+
					" startTime:"+startTime+"timeOffset:"+timeOffset);
			timeOffset = (StorageThread.PERIOD - 1)/1000;
		} else if(timeOffset == StorageThread.PERIOD) {
			timeOffset = (timeOffset-1)/1000;	//a special op for critical value
		}
		else {
			timeOffset /= 1000;
		}
		if(timeOffset > Integer.MAX_VALUE) {
			System.out.println("FATAL ERROR[002] update period too long!");
			System.exit(-1);
		}
		//System.out.println("DEBUG: timeOffset: "+timeOffset);
		webIThroughput[(int)timeOffset][state]++;
	}
}

class ResponseTimeItem<T> implements Iterator<T>{
	public ArrayList<T> webIResponseTime;
	public ResponseTimeItem() {
		super();
		webIResponseTime = new ArrayList<T>(256);
	}
	public void add() {
		
	}
	//implement Iterator interface
	public boolean hasNext() {
		return webIResponseTime.iterator().hasNext();
	}
	public T next() {
		return webIResponseTime.iterator().next();
	}
	public void remove() {
		throw new UnsupportedOperationException();
	}
	public Iterator<T> iterator() {
		return webIResponseTime.iterator();
	}
	//implement end
	public ArrayList<T> get() {
		return webIResponseTime;
	}
}
/**
 * @brief declare the state of StorageThread.
 * 		state=0: init state
 * 		state=1: store state
 * 		state=2: persist state
 */
class StorageState {
	private int state;
	public StorageState() {
		state = 0;
	}
	public void nextState() {
		state = (state+1)%3;
	}
	public int getState() {
		return state;
	}
}
